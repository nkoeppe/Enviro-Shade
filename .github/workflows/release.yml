name: Auto Release Extension

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_publish:
        description: 'Force publish even without src/ changes'
        required: false
        default: false
        type: boolean
  
permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Get current manifest version
      id: manifest
      run: |
        VERSION=$(jq -r '.version' src/manifest.json)
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Current manifest version: $VERSION"
        
    - name: Get latest release version
      id: latest_release
      run: |
        LATEST=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "v0.0.0")
        LATEST_VERSION=${LATEST#v}
        echo "latest=$LATEST_VERSION" >> $GITHUB_OUTPUT
        echo "Latest release version: $LATEST_VERSION"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Check for src/ changes
      id: src_changes
      run: |
        LATEST_TAG="${{ steps.latest_release.outputs.latest }}"
        if [ "$LATEST_TAG" = "0.0.0" ]; then
          # No previous release, consider src changed
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "No previous release found - will publish"
        else
          # Check if src/ has changes since last release
          if git diff --quiet "v$LATEST_TAG" HEAD -- src/; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes in src/ since last release - skipping publish"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes detected in src/ since last release - will publish"
          fi
        fi
        
    - name: Compare versions and decide next version
      id: version
      run: |
        MANIFEST_VERSION="${{ steps.manifest.outputs.version }}"
        LATEST_VERSION="${{ steps.latest_release.outputs.latest }}"
        
        echo "Comparing versions: manifest=$MANIFEST_VERSION, latest=$LATEST_VERSION"
        
        # Function to compare semantic versions
        version_gt() {
          test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
        }
        
        if version_gt "$MANIFEST_VERSION" "$LATEST_VERSION"; then
          # Manifest version is newer, use it
          NEXT_VERSION="$MANIFEST_VERSION"
          echo "Using manifest version: $NEXT_VERSION"
        else
          # Manifest version is same or older, increment patch version
          IFS='.' read -r major minor patch <<< "$LATEST_VERSION"
          NEXT_VERSION="$major.$minor.$((patch + 1))"
          echo "Auto-incrementing to: $NEXT_VERSION"
          
          # Update manifest.json with new version
          jq --arg version "$NEXT_VERSION" '.version = $version' src/manifest.json > tmp.json && mv tmp.json src/manifest.json
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add src/manifest.json
          git commit -m "chore: bump version to $NEXT_VERSION" || echo "No changes to commit"
          git push || echo "No changes to push"
        fi
        
        echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        echo "tag=v$NEXT_VERSION" >> $GITHUB_OUTPUT
        
    - name: Check if release already exists
      id: release_exists
      run: |
        if gh release view "v${{ steps.version.outputs.version }}" >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Release v${{ steps.version.outputs.version }} already exists, skipping..."
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "Release v${{ steps.version.outputs.version }} does not exist, proceeding..."
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Check if should publish
      id: should_publish
      run: |
        RELEASE_EXISTS="${{ steps.release_exists.outputs.exists }}"
        SRC_CHANGES="${{ steps.src_changes.outputs.has_changes }}"
        FORCE_PUBLISH="${{ inputs.force_publish }}"
        
        if [ "$RELEASE_EXISTS" = "true" ]; then
          echo "should_publish=false" >> $GITHUB_OUTPUT
          echo "Skipping: Release already exists"
        elif [ "$FORCE_PUBLISH" = "true" ]; then
          echo "should_publish=true" >> $GITHUB_OUTPUT
          echo "Publishing: Forced publish (manual override)"
        elif [ "$SRC_CHANGES" = "false" ]; then
          echo "should_publish=false" >> $GITHUB_OUTPUT
          echo "Skipping: No changes in src/ directory"
        else
          echo "should_publish=true" >> $GITHUB_OUTPUT
          echo "Publishing: New version with src/ changes"
        fi
        
    - name: Generate release notes
      id: release_notes
      if: steps.should_publish.outputs.should_publish == 'true'
      run: |
        LAST_TAG="${{ steps.latest_release.outputs.latest }}"
        if [ "$LAST_TAG" = "0.0.0" ]; then
          LAST_TAG=""
        else
          LAST_TAG="v$LAST_TAG"
        fi
        
        # Generate changelog from commits
        if [ -n "$LAST_TAG" ]; then
          # Get commits since last tag, excluding merge commits
          COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s (%h)" --no-merges)
        else
          # Get all commits if no previous tag
          COMMITS=$(git log --pretty=format:"%s (%h)" --no-merges --max-count=10)
        fi
        
        # Process commits into categorized changelog
        CHANGELOG=""
        FEATURES=""
        FIXES=""
        CHORES=""
        
        while IFS= read -r commit; do
          if [ -n "$commit" ]; then
            case "$commit" in
              feat*|feature*|add*)
                FEATURES="${FEATURES}- ${commit}\n"
                ;;
              fix*|bug*|patch*)
                FIXES="${FIXES}- ${commit}\n"
                ;;
              chore*|bump*|update*|refactor*|style*)
                CHORES="${CHORES}- ${commit}\n"
                ;;
              *)
                # Default to improvements
                CHANGELOG="${CHANGELOG}- ${commit}\n"
                ;;
            esac
          fi
        done <<< "$COMMITS"
        
        # Build final changelog
        FINAL_CHANGELOG=""
        if [ -n "$FEATURES" ]; then
          FINAL_CHANGELOG="${FINAL_CHANGELOG}### âœ¨ New Features\n${FEATURES}\n"
        fi
        if [ -n "$FIXES" ]; then
          FINAL_CHANGELOG="${FINAL_CHANGELOG}### ðŸ› Bug Fixes\n${FIXES}\n"
        fi
        if [ -n "$CHANGELOG" ]; then
          FINAL_CHANGELOG="${FINAL_CHANGELOG}### ðŸ”§ Improvements\n${CHANGELOG}\n"
        fi
        if [ -n "$CHORES" ]; then
          FINAL_CHANGELOG="${FINAL_CHANGELOG}### ðŸ“¦ Maintenance\n${CHORES}\n"
        fi
        
        # Fallback if no commits found
        if [ -z "$FINAL_CHANGELOG" ]; then
          FINAL_CHANGELOG="### ðŸ”§ Improvements\n- Minor improvements and bug fixes\n"
        fi
        
        CHANGELOG="$FINAL_CHANGELOG"
        
        cat > release_notes.md << EOF
        ## What's Changed
        
        $CHANGELOG
        
        ## Installation
        
        ### Chrome/Edge
        1. Download \`EnviroShade_${{ steps.version.outputs.version }}.zip\`
        2. Extract the ZIP file
        3. Open Chrome/Edge and go to \`chrome://extensions/\` or \`edge://extensions/\`
        4. Enable "Developer mode"
        5. Click "Load unpacked" and select the extracted folder
        
        ### Firefox
        1. Download \`EnviroShade_${{ steps.version.outputs.version }}.zip\`
        2. Open Firefox and go to \`about:debugging\`
        3. Click "This Firefox"
        4. Click "Load Temporary Add-on"
        5. Select the downloaded ZIP file
        
        **Full Changelog**: https://github.com/${{ github.repository }}/compare/${LAST_TAG}...v${{ steps.version.outputs.version }}
        EOF
        
    - name: Create extension ZIP
      if: steps.should_publish.outputs.should_publish == 'true'
      run: |
        # Create the ZIP file from src directory only
        cd src
        zip -r ../EnviroShade_${{ steps.version.outputs.version }}.zip .
        cd ..
        ls -la EnviroShade_${{ steps.version.outputs.version }}.zip
        
    - name: Publish to Firefox Add-ons Store
      if: steps.should_publish.outputs.should_publish == 'true' && vars.PUBLISH_FIREFOX == 'true'
      uses: wdzeng/firefox-addon@v1
      with:
        addon-guid: env-color-banner@fancyguysdev.de
        xpi-path: EnviroShade_${{ steps.version.outputs.version }}.zip
        jwt-issuer: ${{ secrets.FIREFOX_JWT_ISSUER }}
        jwt-secret: ${{ secrets.FIREFOX_JWT_SECRET }}
        approval-notes: |
          Automated release v${{ steps.version.outputs.version }}
          
          This extension adds customizable color banners and watermarks to websites to help identify different environments (PROD, QA, LOCAL, etc.).
          
          Changes in this version:
          - See GitHub release notes for detailed changelog
          
          Source code: https://github.com/${{ github.repository }}
          Release: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.version }}
          
    - name: Create BPP keys configuration
      if: steps.should_publish.outputs.should_publish == 'true' && vars.PUBLISH_CHROME == 'true'
      run: |
        cat > bpp-keys.json << EOF
        {
          "\$schema": "https://github.com/PlasmoHQ/bpp/raw/main/keys.schema.json",
          "chrome": {
            "zip": "EnviroShade_${{ steps.version.outputs.version }}.zip",
            "serviceAccount": ${{ secrets.CHROME_SERVICE_ACCOUNT_KEY }}
          }
        }
        EOF
        
    - name: Publish to Chrome Web Store
      if: steps.should_publish.outputs.should_publish == 'true' && vars.PUBLISH_CHROME == 'true'
      uses: PlasmoHQ/bpp@v3
      with:
        keys: bpp-keys.json
        chrome-file: EnviroShade_${{ steps.version.outputs.version }}.zip
        
    - name: Create GitHub Release
      if: steps.should_publish.outputs.should_publish == 'true'
      run: |
        gh release create "v${{ steps.version.outputs.version }}" \
          --title "Enviro-Shade v${{ steps.version.outputs.version }}" \
          --notes-file release_notes.md \
          EnviroShade_${{ steps.version.outputs.version }}.zip
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}